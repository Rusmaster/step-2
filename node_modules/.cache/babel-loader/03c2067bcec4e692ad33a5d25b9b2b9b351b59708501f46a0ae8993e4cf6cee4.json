{"ast":null,"code":"import { BASE_URL } from \"../constants\";\nexport const FETCH_INGREDIENTS_REQUEST = \"FETCH_INGREDIENTS_REQUEST\";\nexport const FETCH_INGREDIENTS_SUCCESS = \"FETCH_INGREDIENTS_SUCCESS\";\nexport const FETCH_INGREDIENTS_FAILURE = \"FETCH_INGREDIENTS_FAILURE\";\n\n// Создаем типизацию\nexport let TypeActions = /*#__PURE__*/function (TypeActions) {\n  TypeActions[\"FETCH_INGREDIENTS_REQUEST\"] = \"FETCH_INGREDIENTS_REQUEST\";\n  TypeActions[\"FETCH_INGREDIENTS_SUCCESS\"] = \"FETCH_INGREDIENTS_SUCCESS\";\n  TypeActions[\"FETCH_INGREDIENTS_FAILURE\"] = \"FETCH_INGREDIENTS_FAILURE\";\n  return TypeActions;\n}({});\n// Указываем типы\nexport const fetchIngredientsRequest = () => ({\n  type: TypeActions.FETCH_INGREDIENTS_REQUEST\n});\nexport const fetchIngredientsSuccess = ingredients => ({\n  type: TypeActions.FETCH_INGREDIENTS_SUCCESS,\n  payload: ingredients\n});\nexport const fetchIngredientsFailure = error => ({\n  type: TypeActions.FETCH_INGREDIENTS_FAILURE,\n  payload: error\n});\nexport const fetchIngredients = () => {\n  return async dispatch => {\n    dispatch(fetchIngredientsRequest());\n    try {\n      const response = await fetch(`${BASE_URL}/ingredients`);\n      const data = await response.json();\n      if (response.ok) {\n        dispatch(fetchIngredientsSuccess(data.data));\n      } else {\n        dispatch(fetchIngredientsFailure(\"Failed to fetch ingredients\"));\n      }\n    } catch (error) {\n      dispatch(fetchIngredientsFailure(error instanceof Error ? error.message : \"Unknown error\"));\n    }\n  };\n};","map":{"version":3,"names":["BASE_URL","FETCH_INGREDIENTS_REQUEST","FETCH_INGREDIENTS_SUCCESS","FETCH_INGREDIENTS_FAILURE","TypeActions","fetchIngredientsRequest","type","fetchIngredientsSuccess","ingredients","payload","fetchIngredientsFailure","error","fetchIngredients","dispatch","response","fetch","data","json","ok","Error","message"],"sources":["C:/YandexPracticum/step-2 — копия (3) — копия/src/services/actions/ingredientsActions.tsx"],"sourcesContent":["import { BASE_URL } from \"../constants\";\r\nimport { Product } from \"../../types/Product\";\r\nimport { Dispatch } from \"redux\";\r\n\r\nexport const FETCH_INGREDIENTS_REQUEST = \"FETCH_INGREDIENTS_REQUEST\";\r\nexport const FETCH_INGREDIENTS_SUCCESS = \"FETCH_INGREDIENTS_SUCCESS\";\r\nexport const FETCH_INGREDIENTS_FAILURE = \"FETCH_INGREDIENTS_FAILURE\";\r\n\r\n// Создаем типизацию\r\nexport enum TypeActions {\r\n  FETCH_INGREDIENTS_REQUEST = \"FETCH_INGREDIENTS_REQUEST\",\r\n  FETCH_INGREDIENTS_SUCCESS = \"FETCH_INGREDIENTS_SUCCESS\",\r\n  FETCH_INGREDIENTS_FAILURE = \"FETCH_INGREDIENTS_FAILURE\",\r\n}\r\n\r\ninterface FetchIngredientsRequestAction {\r\n  type: TypeActions.FETCH_INGREDIENTS_REQUEST;\r\n}\r\n\r\ninterface FetchIngredientsSuccessAction {\r\n  type: TypeActions.FETCH_INGREDIENTS_SUCCESS;\r\n  payload: Product[];\r\n}\r\n\r\ninterface FetchIngredientsFailureAction {\r\n  type: TypeActions.FETCH_INGREDIENTS_FAILURE;\r\n  payload: string;\r\n}\r\n\r\ntype IngredientsActionTypes =\r\n  | FetchIngredientsRequestAction\r\n  | FetchIngredientsSuccessAction\r\n  | FetchIngredientsFailureAction;\r\n\r\n// Указываем типы\r\nexport const fetchIngredientsRequest = (): FetchIngredientsRequestAction => ({\r\n  type: TypeActions.FETCH_INGREDIENTS_REQUEST,\r\n});\r\n\r\nexport const fetchIngredientsSuccess = (\r\n  ingredients: Product[]\r\n): FetchIngredientsSuccessAction => ({\r\n  type: TypeActions.FETCH_INGREDIENTS_SUCCESS,\r\n  payload: ingredients,\r\n});\r\n\r\nexport const fetchIngredientsFailure = (\r\n  error: string\r\n): FetchIngredientsFailureAction => ({\r\n  type: TypeActions.FETCH_INGREDIENTS_FAILURE,\r\n  payload: error,\r\n});\r\n\r\nexport const fetchIngredients = () => {\r\n  return async (dispatch: Dispatch<IngredientsActionTypes>) => {\r\n    dispatch(fetchIngredientsRequest());\r\n    try {\r\n      const response = await fetch(`${BASE_URL}/ingredients`);\r\n      const data = await response.json();\r\n      if (response.ok) {\r\n        dispatch(fetchIngredientsSuccess(data.data));\r\n      } else {\r\n        dispatch(fetchIngredientsFailure(\"Failed to fetch ingredients\"));\r\n      }\r\n    } catch (error) {\r\n      dispatch(\r\n        fetchIngredientsFailure(\r\n          error instanceof Error ? error.message : \"Unknown error\"\r\n        )\r\n      );\r\n    }\r\n  };\r\n};\r\n"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,cAAc;AAIvC,OAAO,MAAMC,yBAAyB,GAAG,2BAA2B;AACpE,OAAO,MAAMC,yBAAyB,GAAG,2BAA2B;AACpE,OAAO,MAAMC,yBAAyB,GAAG,2BAA2B;;AAEpE;AACA,WAAYC,WAAW,0BAAXA,WAAW;EAAXA,WAAW;EAAXA,WAAW;EAAXA,WAAW;EAAA,OAAXA,WAAW;AAAA;AAyBvB;AACA,OAAO,MAAMC,uBAAuB,GAAGA,CAAA,MAAsC;EAC3EC,IAAI,EAAEF,WAAW,CAACH;AACpB,CAAC,CAAC;AAEF,OAAO,MAAMM,uBAAuB,GAClCC,WAAsB,KACa;EACnCF,IAAI,EAAEF,WAAW,CAACF,yBAAyB;EAC3CO,OAAO,EAAED;AACX,CAAC,CAAC;AAEF,OAAO,MAAME,uBAAuB,GAClCC,KAAa,KACsB;EACnCL,IAAI,EAAEF,WAAW,CAACD,yBAAyB;EAC3CM,OAAO,EAAEE;AACX,CAAC,CAAC;AAEF,OAAO,MAAMC,gBAAgB,GAAGA,CAAA,KAAM;EACpC,OAAO,MAAOC,QAA0C,IAAK;IAC3DA,QAAQ,CAACR,uBAAuB,CAAC,CAAC,CAAC;IACnC,IAAI;MACF,MAAMS,QAAQ,GAAG,MAAMC,KAAK,CAAC,GAAGf,QAAQ,cAAc,CAAC;MACvD,MAAMgB,IAAI,GAAG,MAAMF,QAAQ,CAACG,IAAI,CAAC,CAAC;MAClC,IAAIH,QAAQ,CAACI,EAAE,EAAE;QACfL,QAAQ,CAACN,uBAAuB,CAACS,IAAI,CAACA,IAAI,CAAC,CAAC;MAC9C,CAAC,MAAM;QACLH,QAAQ,CAACH,uBAAuB,CAAC,6BAA6B,CAAC,CAAC;MAClE;IACF,CAAC,CAAC,OAAOC,KAAK,EAAE;MACdE,QAAQ,CACNH,uBAAuB,CACrBC,KAAK,YAAYQ,KAAK,GAAGR,KAAK,CAACS,OAAO,GAAG,eAC3C,CACF,CAAC;IACH;EACF,CAAC;AACH,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}